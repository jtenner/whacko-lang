/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, ReferenceInfo, TypeMetaData } from 'langium';

export type AssignmentExpression = BinaryExpression | LogicalOrExpression | PathExpression;

export const AssignmentExpression = 'AssignmentExpression';

export function isAssignmentExpression(item: unknown): item is AssignmentExpression {
    return reflection.isInstance(item, AssignmentExpression);
}

export type BitShiftExpression = BinaryExpression | SumExpression;

export const BitShiftExpression = 'BitShiftExpression';

export function isBitShiftExpression(item: unknown): item is BitShiftExpression {
    return reflection.isInstance(item, BitShiftExpression);
}

export type BitwiseAndExpression = BinaryExpression | EqualityExpression;

export const BitwiseAndExpression = 'BitwiseAndExpression';

export function isBitwiseAndExpression(item: unknown): item is BitwiseAndExpression {
    return reflection.isInstance(item, BitwiseAndExpression);
}

export type BitwiseOrExpression = BinaryExpression | BitwiseXOrExpression;

export const BitwiseOrExpression = 'BitwiseOrExpression';

export function isBitwiseOrExpression(item: unknown): item is BitwiseOrExpression {
    return reflection.isInstance(item, BitwiseOrExpression);
}

export type BitwiseXOrExpression = BinaryExpression | BitwiseAndExpression;

export const BitwiseXOrExpression = 'BitwiseXOrExpression';

export function isBitwiseXOrExpression(item: unknown): item is BitwiseXOrExpression {
    return reflection.isInstance(item, BitwiseXOrExpression);
}

export type ComaprisonExpression = BinaryExpression | BitShiftExpression;

export const ComaprisonExpression = 'ComaprisonExpression';

export function isComaprisonExpression(item: unknown): item is ComaprisonExpression {
    return reflection.isInstance(item, ComaprisonExpression);
}

export type EqualityExpression = BinaryExpression | ComaprisonExpression;

export const EqualityExpression = 'EqualityExpression';

export function isEqualityExpression(item: unknown): item is EqualityExpression {
    return reflection.isInstance(item, EqualityExpression);
}

export type ExponentiationExpression = BinaryExpression | LeftUnaryExpression;

export const ExponentiationExpression = 'ExponentiationExpression';

export function isExponentiationExpression(item: unknown): item is ExponentiationExpression {
    return reflection.isInstance(item, ExponentiationExpression);
}

export type Expression = TupleExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type LogicalAndExpression = BinaryExpression | BitwiseOrExpression;

export const LogicalAndExpression = 'LogicalAndExpression';

export function isLogicalAndExpression(item: unknown): item is LogicalAndExpression {
    return reflection.isInstance(item, LogicalAndExpression);
}

export type LogicalOrExpression = BinaryExpression | LogicalAndExpression;

export const LogicalOrExpression = 'LogicalOrExpression';

export function isLogicalOrExpression(item: unknown): item is LogicalOrExpression {
    return reflection.isInstance(item, LogicalOrExpression);
}

export type PrimaryExpression = AsyncBlockLiteral | BinaryLiteral | FalseLiteral | FloatLiteral | GroupLiteral | HexLiteral | ID | IntegerLiteral | NullLiteral | OctalLiteral | StringLiteral | SuperLiteral | ThisLiteral | TrueLiteral;

export const PrimaryExpression = 'PrimaryExpression';

export function isPrimaryExpression(item: unknown): item is PrimaryExpression {
    return reflection.isInstance(item, PrimaryExpression);
}

export type ProductExpression = BinaryExpression | ExponentiationExpression;

export const ProductExpression = 'ProductExpression';

export function isProductExpression(item: unknown): item is ProductExpression {
    return reflection.isInstance(item, ProductExpression);
}

export type SumExpression = BinaryExpression | ProductExpression;

export const SumExpression = 'SumExpression';

export function isSumExpression(item: unknown): item is SumExpression {
    return reflection.isInstance(item, SumExpression);
}

export type TypeExpression = FunctionTypeExpression | HeldTypeExpression | NamedTypeExpression | TupleTypeExpression;

export const TypeExpression = 'TypeExpression';

export function isTypeExpression(item: unknown): item is TypeExpression {
    return reflection.isInstance(item, TypeExpression);
}

export interface ArrayAccessPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'ArrayAccessPath';
    expression: Expression
}

export const ArrayAccessPath = 'ArrayAccessPath';

export function isArrayAccessPath(item: unknown): item is ArrayAccessPath {
    return reflection.isInstance(item, ArrayAccessPath);
}

export interface AsyncBlockLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AsyncBlockLiteral';
    statements: Array<Statement>
    type?: TypeExpression
}

export const AsyncBlockLiteral = 'AsyncBlockLiteral';

export function isAsyncBlockLiteral(item: unknown): item is AsyncBlockLiteral {
    return reflection.isInstance(item, AsyncBlockLiteral);
}

export interface BinaryExpression extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'BinaryExpression';
    lhs: BitShiftExpression | BitwiseAndExpression | BitwiseOrExpression | BitwiseXOrExpression | ComaprisonExpression | EqualityExpression | ExponentiationExpression | LeftUnaryExpression | LogicalAndExpression | PathExpression | ProductExpression | SumExpression
    op: '!=' | '%' | '%=' | '&&' | '&&=' | '&' | '&=' | '*' | '**' | '**=' | '*=' | '+' | '+=' | '-' | '-=' | '/' | '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '>>>=' | '??=' | '^' | '^=' | '|' | '|=' | '||' | '||='
    rhs: BitShiftExpression | BitwiseAndExpression | BitwiseOrExpression | BitwiseXOrExpression | ComaprisonExpression | EqualityExpression | ExponentiationExpression | LeftUnaryExpression | LogicalAndExpression | LogicalOrExpression | ProductExpression | SumExpression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BinaryLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'BinaryLiteral';
    value: string
}

export const BinaryLiteral = 'BinaryLiteral';

export function isBinaryLiteral(item: unknown): item is BinaryLiteral {
    return reflection.isInstance(item, BinaryLiteral);
}

export interface CallPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'CallPath';
    typeParameters: Array<TypeExpression>
}

export const CallPath = 'CallPath';

export function isCallPath(item: unknown): item is CallPath {
    return reflection.isInstance(item, CallPath);
}

export interface ClassMember extends AstNode {
    readonly $container: Declaration;
    readonly $type: 'ClassMember';
    members: Array<ConstructorClassMember> | Array<FieldClassMember> | Array<GetterClassMember> | Array<MethodClassMember> | Array<SetterClassMember>
}

export const ClassMember = 'ClassMember';

export function isClassMember(item: unknown): item is ClassMember {
    return reflection.isInstance(item, ClassMember);
}

export interface ConstructorClassMember extends AstNode {
    readonly $container: ClassMember;
    readonly $type: 'ConstructorClassMember';
    block: Statement
    parameters: Array<Parameter>
    private?: 'private'
}

export const ConstructorClassMember = 'ConstructorClassMember';

export function isConstructorClassMember(item: unknown): item is ConstructorClassMember {
    return reflection.isInstance(item, ConstructorClassMember);
}

export interface Declaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'Declaration';
    async?: 'async'
    block?: Statement
    declarators: Array<ExportDeclarator> | Array<ImportDeclarator>
    extends?: TypeExpression
    final?: 'final'
    members: Array<ClassMember>
    method?: string
    name?: ID
    namespace?: string
    parameters: Array<Parameter>
    path?: string
    returnType?: TypeExpression
    type?: TypeExpression
}

export const Declaration = 'Declaration';

export function isDeclaration(item: unknown): item is Declaration {
    return reflection.isInstance(item, Declaration);
}

export interface ExportDeclarator extends AstNode {
    readonly $container: Declaration;
    readonly $type: 'ExportDeclarator';
    alias?: ID
    name: ID
}

export const ExportDeclarator = 'ExportDeclarator';

export function isExportDeclarator(item: unknown): item is ExportDeclarator {
    return reflection.isInstance(item, ExportDeclarator);
}

export interface FalseLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'FalseLiteral';
    false: 'false'
}

export const FalseLiteral = 'FalseLiteral';

export function isFalseLiteral(item: unknown): item is FalseLiteral {
    return reflection.isInstance(item, FalseLiteral);
}

export interface FieldClassMember extends AstNode {
    readonly $container: ClassMember;
    readonly $type: 'FieldClassMember';
    initializer?: Expression
    name: ID
    private?: 'private'
    type: TypeExpression
}

export const FieldClassMember = 'FieldClassMember';

export function isFieldClassMember(item: unknown): item is FieldClassMember {
    return reflection.isInstance(item, FieldClassMember);
}

export interface FloatLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'FloatLiteral';
    value: string
}

export const FloatLiteral = 'FloatLiteral';

export function isFloatLiteral(item: unknown): item is FloatLiteral {
    return reflection.isInstance(item, FloatLiteral);
}

export interface FunctionTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | Declaration | FieldClassMember | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewPath | Statement | TupleTypeExpression | VariableDeclarator;
    readonly $type: 'FunctionTypeExpression';
    parameters: Array<TypeExpression>
    returnType: TypeExpression
}

export const FunctionTypeExpression = 'FunctionTypeExpression';

export function isFunctionTypeExpression(item: unknown): item is FunctionTypeExpression {
    return reflection.isInstance(item, FunctionTypeExpression);
}

export interface GetterClassMember extends AstNode {
    readonly $container: ClassMember;
    readonly $type: 'GetterClassMember';
    block: Statement
    name: ID
    private?: 'private'
    returnType: TypeExpression
}

export const GetterClassMember = 'GetterClassMember';

export function isGetterClassMember(item: unknown): item is GetterClassMember {
    return reflection.isInstance(item, GetterClassMember);
}

export interface GroupLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'GroupLiteral';
    expression: Expression
}

export const GroupLiteral = 'GroupLiteral';

export function isGroupLiteral(item: unknown): item is GroupLiteral {
    return reflection.isInstance(item, GroupLiteral);
}

export interface HeldTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | Declaration | FieldClassMember | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewPath | Statement | TupleTypeExpression | VariableDeclarator;
    readonly $type: 'HeldTypeExpression';
    type: TypeExpression
}

export const HeldTypeExpression = 'HeldTypeExpression';

export function isHeldTypeExpression(item: unknown): item is HeldTypeExpression {
    return reflection.isInstance(item, HeldTypeExpression);
}

export interface HexLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'HexLiteral';
    value: string
}

export const HexLiteral = 'HexLiteral';

export function isHexLiteral(item: unknown): item is HexLiteral {
    return reflection.isInstance(item, HexLiteral);
}

export interface ID extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'ID';
    name: string
}

export const ID = 'ID';

export function isID(item: unknown): item is ID {
    return reflection.isInstance(item, ID);
}

export interface ImportDeclarator extends AstNode {
    readonly $container: Declaration;
    readonly $type: 'ImportDeclarator';
    alias?: ID
    name: ID
}

export const ImportDeclarator = 'ImportDeclarator';

export function isImportDeclarator(item: unknown): item is ImportDeclarator {
    return reflection.isInstance(item, ImportDeclarator);
}

export interface IntegerLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'IntegerLiteral';
    value: string
}

export const IntegerLiteral = 'IntegerLiteral';

export function isIntegerLiteral(item: unknown): item is IntegerLiteral {
    return reflection.isInstance(item, IntegerLiteral);
}

export interface LeftUnaryExpression extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'AwaitExpression' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'GroupLiteral' | 'HexLiteral' | 'HoldExpression' | 'ID' | 'IntegerLiteral' | 'LeftUnaryExpression' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: LeftUnaryExpression
    op: '!' | '+' | '-' | '~'
}

export const LeftUnaryExpression = 'LeftUnaryExpression';

export function isLeftUnaryExpression(item: unknown): item is LeftUnaryExpression {
    return reflection.isInstance(item, LeftUnaryExpression);
}

export interface MemberAccessPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'MemberAccessPath';
    member: ID
}

export const MemberAccessPath = 'MemberAccessPath';

export function isMemberAccessPath(item: unknown): item is MemberAccessPath {
    return reflection.isInstance(item, MemberAccessPath);
}

export interface MethodClassMember extends AstNode {
    readonly $container: ClassMember;
    readonly $type: 'MethodClassMember';
    block: Statement
    name: ID
    parameters: Array<Parameter>
    private?: 'private'
    returnType: TypeExpression
}

export const MethodClassMember = 'MethodClassMember';

export function isMethodClassMember(item: unknown): item is MethodClassMember {
    return reflection.isInstance(item, MethodClassMember);
}

export interface NamedTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | Declaration | FieldClassMember | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewPath | Statement | TupleTypeExpression | VariableDeclarator;
    readonly $type: 'NamedTypeExpression';
    name: ID
    typeParameters: Array<TypeExpression>
}

export const NamedTypeExpression = 'NamedTypeExpression';

export function isNamedTypeExpression(item: unknown): item is NamedTypeExpression {
    return reflection.isInstance(item, NamedTypeExpression);
}

export interface NewPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'NewPath';
    parameters: Array<Expression>
    typeParameters: Array<TypeExpression>
}

export const NewPath = 'NewPath';

export function isNewPath(item: unknown): item is NewPath {
    return reflection.isInstance(item, NewPath);
}

export interface NullLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'NullLiteral';
    null: 'null'
}

export const NullLiteral = 'NullLiteral';

export function isNullLiteral(item: unknown): item is NullLiteral {
    return reflection.isInstance(item, NullLiteral);
}

export interface OctalLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'OctalLiteral';
    value: string
}

export const OctalLiteral = 'OctalLiteral';

export function isOctalLiteral(item: unknown): item is OctalLiteral {
    return reflection.isInstance(item, OctalLiteral);
}

export interface Parameter extends AstNode {
    readonly $container: ConstructorClassMember | Declaration | MethodClassMember | SetterClassMember;
    readonly $type: 'Parameter';
    name: ID
    type: ID
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface Program extends AstNode {
    readonly $type: 'Program';
    declarations: Array<Declaration>
    exports: Array<Declaration>
    imports: Array<Declaration>
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface SetterClassMember extends AstNode {
    readonly $container: ClassMember;
    readonly $type: 'SetterClassMember';
    block: Statement
    name: ID
    parameter: Parameter
    private?: 'private'
}

export const SetterClassMember = 'SetterClassMember';

export function isSetterClassMember(item: unknown): item is SetterClassMember {
    return reflection.isInstance(item, SetterClassMember);
}

export interface Statement extends AstNode {
    readonly $container: AsyncBlockLiteral | ConstructorClassMember | Declaration | GetterClassMember | MethodClassMember | SetterClassMember | Statement;
    readonly $type: 'Statement';
    brk?: 'break'
    condition?: Expression
    cont?: 'continue'
    declarationType?: 'const' | 'let'
    declarators: Array<VariableDeclarator>
    expression?: Expression
    falsy?: Statement
    heldExpression?: Expression
    name?: ID
    statement?: Statement
    statements: Array<Statement>
    truthy?: Statement
    type?: TypeExpression
}

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export interface StringLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'StringLiteral';
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface SuperLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'SuperLiteral';
    super: 'super'
}

export const SuperLiteral = 'SuperLiteral';

export function isSuperLiteral(item: unknown): item is SuperLiteral {
    return reflection.isInstance(item, SuperLiteral);
}

export interface ThisLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'ThisLiteral';
    this: 'this'
}

export const ThisLiteral = 'ThisLiteral';

export function isThisLiteral(item: unknown): item is ThisLiteral {
    return reflection.isInstance(item, ThisLiteral);
}

export interface TrueLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'TrueLiteral';
    true: 'true'
}

export const TrueLiteral = 'TrueLiteral';

export function isTrueLiteral(item: unknown): item is TrueLiteral {
    return reflection.isInstance(item, TrueLiteral);
}

export interface TupleExpression extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AssignmentExpression' | 'BinaryExpression' | 'TernaryExpression' | 'TupleExpression' | 'YieldExpression';
    expressions: Array<Expression>
}

export const TupleExpression = 'TupleExpression';

export function isTupleExpression(item: unknown): item is TupleExpression {
    return reflection.isInstance(item, TupleExpression);
}

export interface TupleTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | Declaration | FieldClassMember | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewPath | Statement | TupleTypeExpression | VariableDeclarator;
    readonly $type: 'TupleTypeExpression';
    types: Array<TypeExpression>
}

export const TupleTypeExpression = 'TupleTypeExpression';

export function isTupleTypeExpression(item: unknown): item is TupleTypeExpression {
    return reflection.isInstance(item, TupleTypeExpression);
}

export interface VariableDeclarator extends AstNode {
    readonly $container: Statement;
    readonly $type: 'VariableDeclarator';
    expression: Expression
    name: ID
    type?: TypeExpression
}

export const VariableDeclarator = 'VariableDeclarator';

export function isVariableDeclarator(item: unknown): item is VariableDeclarator {
    return reflection.isInstance(item, VariableDeclarator);
}

export interface AwaitExpression extends LeftUnaryExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'AwaitExpression' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'GroupLiteral' | 'HexLiteral' | 'HoldExpression' | 'ID' | 'IntegerLiteral' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: LeftUnaryExpression
}

export const AwaitExpression = 'AwaitExpression';

export function isAwaitExpression(item: unknown): item is AwaitExpression {
    return reflection.isInstance(item, AwaitExpression);
}

export interface YieldExpression extends TupleExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AssignmentExpression' | 'BinaryExpression' | 'TernaryExpression' | 'YieldExpression';
    expression: YieldExpression
}

export const YieldExpression = 'YieldExpression';

export function isYieldExpression(item: unknown): item is YieldExpression {
    return reflection.isInstance(item, YieldExpression);
}

export interface HoldExpression extends AwaitExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'GroupLiteral' | 'HexLiteral' | 'HoldExpression' | 'ID' | 'IntegerLiteral' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: LeftUnaryExpression
}

export const HoldExpression = 'HoldExpression';

export function isHoldExpression(item: unknown): item is HoldExpression {
    return reflection.isInstance(item, HoldExpression);
}

export interface TernaryExpression extends YieldExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AssignmentExpression' | 'BinaryExpression' | 'TernaryExpression';
    condition: AssignmentExpression
    falsy: TernaryExpression
    truthy: TernaryExpression
}

export const TernaryExpression = 'TernaryExpression';

export function isTernaryExpression(item: unknown): item is TernaryExpression {
    return reflection.isInstance(item, TernaryExpression);
}

export interface PathExpression extends HoldExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | Declaration | ExportDeclarator | FieldClassMember | GetterClassMember | GroupLiteral | HoldExpression | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewPath | Parameter | PathExpression | SetterClassMember | Statement | TernaryExpression | TupleExpression | VariableDeclarator | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'GroupLiteral' | 'HexLiteral' | 'ID' | 'IntegerLiteral' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    path: Array<ArrayAccessPath> | Array<CallPath> | Array<MemberAccessPath> | Array<NewPath>
    root: PrimaryExpression
}

export const PathExpression = 'PathExpression';

export function isPathExpression(item: unknown): item is PathExpression {
    return reflection.isInstance(item, PathExpression);
}

export interface WhackoAstType {
    ArrayAccessPath: ArrayAccessPath
    AssignmentExpression: AssignmentExpression
    AsyncBlockLiteral: AsyncBlockLiteral
    AwaitExpression: AwaitExpression
    BinaryExpression: BinaryExpression
    BinaryLiteral: BinaryLiteral
    BitShiftExpression: BitShiftExpression
    BitwiseAndExpression: BitwiseAndExpression
    BitwiseOrExpression: BitwiseOrExpression
    BitwiseXOrExpression: BitwiseXOrExpression
    CallPath: CallPath
    ClassMember: ClassMember
    ComaprisonExpression: ComaprisonExpression
    ConstructorClassMember: ConstructorClassMember
    Declaration: Declaration
    EqualityExpression: EqualityExpression
    ExponentiationExpression: ExponentiationExpression
    ExportDeclarator: ExportDeclarator
    Expression: Expression
    FalseLiteral: FalseLiteral
    FieldClassMember: FieldClassMember
    FloatLiteral: FloatLiteral
    FunctionTypeExpression: FunctionTypeExpression
    GetterClassMember: GetterClassMember
    GroupLiteral: GroupLiteral
    HeldTypeExpression: HeldTypeExpression
    HexLiteral: HexLiteral
    HoldExpression: HoldExpression
    ID: ID
    ImportDeclarator: ImportDeclarator
    IntegerLiteral: IntegerLiteral
    LeftUnaryExpression: LeftUnaryExpression
    LogicalAndExpression: LogicalAndExpression
    LogicalOrExpression: LogicalOrExpression
    MemberAccessPath: MemberAccessPath
    MethodClassMember: MethodClassMember
    NamedTypeExpression: NamedTypeExpression
    NewPath: NewPath
    NullLiteral: NullLiteral
    OctalLiteral: OctalLiteral
    Parameter: Parameter
    PathExpression: PathExpression
    PrimaryExpression: PrimaryExpression
    ProductExpression: ProductExpression
    Program: Program
    SetterClassMember: SetterClassMember
    Statement: Statement
    StringLiteral: StringLiteral
    SumExpression: SumExpression
    SuperLiteral: SuperLiteral
    TernaryExpression: TernaryExpression
    ThisLiteral: ThisLiteral
    TrueLiteral: TrueLiteral
    TupleExpression: TupleExpression
    TupleTypeExpression: TupleTypeExpression
    TypeExpression: TypeExpression
    VariableDeclarator: VariableDeclarator
    YieldExpression: YieldExpression
}

export class WhackoAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['ArrayAccessPath', 'AssignmentExpression', 'AsyncBlockLiteral', 'AwaitExpression', 'BinaryExpression', 'BinaryLiteral', 'BitShiftExpression', 'BitwiseAndExpression', 'BitwiseOrExpression', 'BitwiseXOrExpression', 'CallPath', 'ClassMember', 'ComaprisonExpression', 'ConstructorClassMember', 'Declaration', 'EqualityExpression', 'ExponentiationExpression', 'ExportDeclarator', 'Expression', 'FalseLiteral', 'FieldClassMember', 'FloatLiteral', 'FunctionTypeExpression', 'GetterClassMember', 'GroupLiteral', 'HeldTypeExpression', 'HexLiteral', 'HoldExpression', 'ID', 'ImportDeclarator', 'IntegerLiteral', 'LeftUnaryExpression', 'LogicalAndExpression', 'LogicalOrExpression', 'MemberAccessPath', 'MethodClassMember', 'NamedTypeExpression', 'NewPath', 'NullLiteral', 'OctalLiteral', 'Parameter', 'PathExpression', 'PrimaryExpression', 'ProductExpression', 'Program', 'SetterClassMember', 'Statement', 'StringLiteral', 'SumExpression', 'SuperLiteral', 'TernaryExpression', 'ThisLiteral', 'TrueLiteral', 'TupleExpression', 'TupleTypeExpression', 'TypeExpression', 'VariableDeclarator', 'YieldExpression'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AsyncBlockLiteral:
            case BinaryLiteral:
            case FalseLiteral:
            case FloatLiteral:
            case GroupLiteral:
            case HexLiteral:
            case ID:
            case IntegerLiteral:
            case NullLiteral:
            case OctalLiteral:
            case StringLiteral:
            case SuperLiteral:
            case ThisLiteral:
            case TrueLiteral: {
                return this.isSubtype(PrimaryExpression, supertype);
            }
            case BinaryExpression: {
                return this.isSubtype(AssignmentExpression, supertype) || this.isSubtype(LogicalOrExpression, supertype) || this.isSubtype(LogicalAndExpression, supertype) || this.isSubtype(BitwiseOrExpression, supertype) || this.isSubtype(BitwiseXOrExpression, supertype) || this.isSubtype(BitwiseAndExpression, supertype) || this.isSubtype(EqualityExpression, supertype) || this.isSubtype(ComaprisonExpression, supertype) || this.isSubtype(BitShiftExpression, supertype) || this.isSubtype(SumExpression, supertype) || this.isSubtype(ProductExpression, supertype) || this.isSubtype(ExponentiationExpression, supertype);
            }
            case FunctionTypeExpression:
            case HeldTypeExpression:
            case NamedTypeExpression:
            case TupleTypeExpression: {
                return this.isSubtype(TypeExpression, supertype);
            }
            case LeftUnaryExpression: {
                return this.isSubtype(ExponentiationExpression, supertype);
            }
            case TupleExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case AwaitExpression: {
                return this.isSubtype(LeftUnaryExpression, supertype);
            }
            case YieldExpression: {
                return this.isSubtype(TupleExpression, supertype);
            }
            case HoldExpression: {
                return this.isSubtype(AwaitExpression, supertype);
            }
            case TernaryExpression: {
                return this.isSubtype(YieldExpression, supertype);
            }
            case PathExpression: {
                return this.isSubtype(AssignmentExpression, supertype) || this.isSubtype(HoldExpression, supertype);
            }
            case AssignmentExpression: {
                return this.isSubtype(TernaryExpression, supertype);
            }
            case BitShiftExpression: {
                return this.isSubtype(ComaprisonExpression, supertype);
            }
            case BitwiseAndExpression: {
                return this.isSubtype(BitwiseXOrExpression, supertype);
            }
            case BitwiseOrExpression: {
                return this.isSubtype(LogicalAndExpression, supertype);
            }
            case BitwiseXOrExpression: {
                return this.isSubtype(BitwiseOrExpression, supertype);
            }
            case ComaprisonExpression: {
                return this.isSubtype(EqualityExpression, supertype);
            }
            case EqualityExpression: {
                return this.isSubtype(BitwiseAndExpression, supertype);
            }
            case ExponentiationExpression: {
                return this.isSubtype(ProductExpression, supertype);
            }
            case LogicalAndExpression: {
                return this.isSubtype(LogicalOrExpression, supertype);
            }
            case LogicalOrExpression: {
                return this.isSubtype(AssignmentExpression, supertype);
            }
            case PrimaryExpression: {
                return this.isSubtype(PathExpression, supertype);
            }
            case ProductExpression: {
                return this.isSubtype(SumExpression, supertype);
            }
            case SumExpression: {
                return this.isSubtype(BitShiftExpression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'AsyncBlockLiteral': {
                return {
                    name: 'AsyncBlockLiteral',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'CallPath': {
                return {
                    name: 'CallPath',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'ClassMember': {
                return {
                    name: 'ClassMember',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            case 'ConstructorClassMember': {
                return {
                    name: 'ConstructorClassMember',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'Declaration': {
                return {
                    name: 'Declaration',
                    mandatory: [
                        { name: 'declarators', type: 'array' },
                        { name: 'members', type: 'array' },
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'FunctionTypeExpression': {
                return {
                    name: 'FunctionTypeExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'MethodClassMember': {
                return {
                    name: 'MethodClassMember',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'NamedTypeExpression': {
                return {
                    name: 'NamedTypeExpression',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'NewPath': {
                return {
                    name: 'NewPath',
                    mandatory: [
                        { name: 'parameters', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'Program': {
                return {
                    name: 'Program',
                    mandatory: [
                        { name: 'declarations', type: 'array' },
                        { name: 'exports', type: 'array' },
                        { name: 'imports', type: 'array' }
                    ]
                };
            }
            case 'Statement': {
                return {
                    name: 'Statement',
                    mandatory: [
                        { name: 'declarators', type: 'array' },
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'TupleExpression': {
                return {
                    name: 'TupleExpression',
                    mandatory: [
                        { name: 'expressions', type: 'array' }
                    ]
                };
            }
            case 'TupleTypeExpression': {
                return {
                    name: 'TupleTypeExpression',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'YieldExpression': {
                return {
                    name: 'YieldExpression',
                    mandatory: [
                        { name: 'expressions', type: 'array' }
                    ]
                };
            }
            case 'TernaryExpression': {
                return {
                    name: 'TernaryExpression',
                    mandatory: [
                        { name: 'expressions', type: 'array' }
                    ]
                };
            }
            case 'PathExpression': {
                return {
                    name: 'PathExpression',
                    mandatory: [
                        { name: 'path', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new WhackoAstReflection();
