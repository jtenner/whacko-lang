/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, ReferenceInfo, TypeMetaData } from 'langium';

export type AssignmentExpression = BinaryExpression | LogicalOrExpression | PathExpression;

export const AssignmentExpression = 'AssignmentExpression';

export function isAssignmentExpression(item: unknown): item is AssignmentExpression {
    return reflection.isInstance(item, AssignmentExpression);
}

export type BitShiftExpression = BinaryExpression | SumExpression;

export const BitShiftExpression = 'BitShiftExpression';

export function isBitShiftExpression(item: unknown): item is BitShiftExpression {
    return reflection.isInstance(item, BitShiftExpression);
}

export type BitwiseAndExpression = BinaryExpression | EqualityExpression;

export const BitwiseAndExpression = 'BitwiseAndExpression';

export function isBitwiseAndExpression(item: unknown): item is BitwiseAndExpression {
    return reflection.isInstance(item, BitwiseAndExpression);
}

export type BitwiseOrExpression = BinaryExpression | BitwiseXOrExpression;

export const BitwiseOrExpression = 'BitwiseOrExpression';

export function isBitwiseOrExpression(item: unknown): item is BitwiseOrExpression {
    return reflection.isInstance(item, BitwiseOrExpression);
}

export type BitwiseXOrExpression = BinaryExpression | BitwiseAndExpression;

export const BitwiseXOrExpression = 'BitwiseXOrExpression';

export function isBitwiseXOrExpression(item: unknown): item is BitwiseXOrExpression {
    return reflection.isInstance(item, BitwiseXOrExpression);
}

export type ClassMember = ConstructorClassMember | FieldClassMember | GetterClassMember | MethodClassMember | SetterClassMember;

export const ClassMember = 'ClassMember';

export function isClassMember(item: unknown): item is ClassMember {
    return reflection.isInstance(item, ClassMember);
}

export type ComaprisonExpression = BinaryExpression | BitShiftExpression;

export const ComaprisonExpression = 'ComaprisonExpression';

export function isComaprisonExpression(item: unknown): item is ComaprisonExpression {
    return reflection.isInstance(item, ComaprisonExpression);
}

export type EqualityExpression = BinaryExpression | ComaprisonExpression;

export const EqualityExpression = 'EqualityExpression';

export function isEqualityExpression(item: unknown): item is EqualityExpression {
    return reflection.isInstance(item, EqualityExpression);
}

export type ExponentiationExpression = BinaryExpression | LeftUnaryExpression;

export const ExponentiationExpression = 'ExponentiationExpression';

export function isExponentiationExpression(item: unknown): item is ExponentiationExpression {
    return reflection.isInstance(item, ExponentiationExpression);
}

export type Expression = TupleExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type LogicalAndExpression = BinaryExpression | BitwiseOrExpression;

export const LogicalAndExpression = 'LogicalAndExpression';

export function isLogicalAndExpression(item: unknown): item is LogicalAndExpression {
    return reflection.isInstance(item, LogicalAndExpression);
}

export type LogicalOrExpression = BinaryExpression | LogicalAndExpression;

export const LogicalOrExpression = 'LogicalOrExpression';

export function isLogicalOrExpression(item: unknown): item is LogicalOrExpression {
    return reflection.isInstance(item, LogicalOrExpression);
}

export type PrimaryExpression = AsyncBlockLiteral | BinaryLiteral | FalseLiteral | FloatLiteral | FunctionLiteral | GroupLiteral | HexLiteral | ID | IntegerLiteral | NullLiteral | OctalLiteral | StringLiteral | SuperLiteral | ThisLiteral | TrueLiteral;

export const PrimaryExpression = 'PrimaryExpression';

export function isPrimaryExpression(item: unknown): item is PrimaryExpression {
    return reflection.isInstance(item, PrimaryExpression);
}

export type ProductExpression = BinaryExpression | ExponentiationExpression;

export const ProductExpression = 'ProductExpression';

export function isProductExpression(item: unknown): item is ProductExpression {
    return reflection.isInstance(item, ProductExpression);
}

export type Statement = BlockStatement | BreakStatement | ContinueStatement | ExpressionStatement | GrabStatement | IfElseStatement | ReturnStatement | TypeDeclarationStatement | VariableDeclarationStatement | WhileStatement;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type SumExpression = BinaryExpression | ProductExpression;

export const SumExpression = 'SumExpression';

export function isSumExpression(item: unknown): item is SumExpression {
    return reflection.isInstance(item, SumExpression);
}

export type TypeExpression = FunctionTypeExpression | HeldTypeExpression | NamedTypeExpression | TupleTypeExpression;

export const TypeExpression = 'TypeExpression';

export function isTypeExpression(item: unknown): item is TypeExpression {
    return reflection.isInstance(item, TypeExpression);
}

export interface ArrayAccessPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'ArrayAccessPath';
    expression: Expression
}

export const ArrayAccessPath = 'ArrayAccessPath';

export function isArrayAccessPath(item: unknown): item is ArrayAccessPath {
    return reflection.isInstance(item, ArrayAccessPath);
}

export interface AsyncBlockLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AsyncBlockLiteral';
    block: BlockStatement
    type?: TypeExpression
}

export const AsyncBlockLiteral = 'AsyncBlockLiteral';

export function isAsyncBlockLiteral(item: unknown): item is AsyncBlockLiteral {
    return reflection.isInstance(item, AsyncBlockLiteral);
}

export interface BinaryExpression extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'BinaryExpression';
    lhs: BitShiftExpression | BitwiseAndExpression | BitwiseOrExpression | BitwiseXOrExpression | ComaprisonExpression | EqualityExpression | ExponentiationExpression | LeftUnaryExpression | LogicalAndExpression | PathExpression | ProductExpression | SumExpression
    op: '!=' | '%' | '%=' | '&&' | '&&=' | '&' | '&=' | '*' | '**' | '**=' | '*=' | '+' | '+=' | '-' | '-=' | '/' | '/=' | '<' | '<<' | '<<=' | '<=' | '=' | '==' | '>' | '>=' | '>>' | '>>=' | '>>>=' | '??=' | '^' | '^=' | '|' | '|=' | '||' | '||='
    rhs: BitShiftExpression | BitwiseAndExpression | BitwiseOrExpression | BitwiseXOrExpression | ComaprisonExpression | EqualityExpression | ExponentiationExpression | LeftUnaryExpression | LogicalAndExpression | LogicalOrExpression | ProductExpression | SumExpression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BinaryLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'BinaryLiteral';
    value: string
}

export const BinaryLiteral = 'BinaryLiteral';

export function isBinaryLiteral(item: unknown): item is BinaryLiteral {
    return reflection.isInstance(item, BinaryLiteral);
}

export interface BlockStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'BlockStatement';
    statements: Array<Statement>
}

export const BlockStatement = 'BlockStatement';

export function isBlockStatement(item: unknown): item is BlockStatement {
    return reflection.isInstance(item, BlockStatement);
}

export interface BreakStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'BreakStatement';
    brk: 'break'
}

export const BreakStatement = 'BreakStatement';

export function isBreakStatement(item: unknown): item is BreakStatement {
    return reflection.isInstance(item, BreakStatement);
}

export interface CallPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'CallPath';
    parameters: Array<Expression>
    typeParameters: Array<TypeExpression>
}

export const CallPath = 'CallPath';

export function isCallPath(item: unknown): item is CallPath {
    return reflection.isInstance(item, CallPath);
}

export interface ClassDeclaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'ClassDeclaration';
    export?: 'export'
    extends?: TypeExpression
    final?: 'final'
    members: Array<ClassMember>
    name: ID
}

export const ClassDeclaration = 'ClassDeclaration';

export function isClassDeclaration(item: unknown): item is ClassDeclaration {
    return reflection.isInstance(item, ClassDeclaration);
}

export interface ConstructorClassMember extends AstNode {
    readonly $container: ClassDeclaration;
    readonly $type: 'ConstructorClassMember';
    block: BlockStatement
    parameters: Array<Parameter>
    private?: 'private'
}

export const ConstructorClassMember = 'ConstructorClassMember';

export function isConstructorClassMember(item: unknown): item is ConstructorClassMember {
    return reflection.isInstance(item, ConstructorClassMember);
}

export interface ContinueStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'ContinueStatement';
    cont: 'continue'
}

export const ContinueStatement = 'ContinueStatement';

export function isContinueStatement(item: unknown): item is ContinueStatement {
    return reflection.isInstance(item, ContinueStatement);
}

export interface DeclareDeclaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'DeclareDeclaration';
    export?: 'export'
    method: string
    name: ID
    namespace: string
    parameters: Array<Parameter>
    returnType: TypeExpression
}

export const DeclareDeclaration = 'DeclareDeclaration';

export function isDeclareDeclaration(item: unknown): item is DeclareDeclaration {
    return reflection.isInstance(item, DeclareDeclaration);
}

export interface ExportDeclaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'ExportDeclaration';
    declarators: Array<ExportDeclarator>
}

export const ExportDeclaration = 'ExportDeclaration';

export function isExportDeclaration(item: unknown): item is ExportDeclaration {
    return reflection.isInstance(item, ExportDeclaration);
}

export interface ExportDeclarator extends AstNode {
    readonly $container: ExportDeclaration;
    readonly $type: 'ExportDeclarator';
    alias?: ID
    name: ID
}

export const ExportDeclarator = 'ExportDeclarator';

export function isExportDeclarator(item: unknown): item is ExportDeclarator {
    return reflection.isInstance(item, ExportDeclarator);
}

export interface ExpressionStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'ExpressionStatement';
    expression: Expression
}

export const ExpressionStatement = 'ExpressionStatement';

export function isExpressionStatement(item: unknown): item is ExpressionStatement {
    return reflection.isInstance(item, ExpressionStatement);
}

export interface FalseLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'FalseLiteral';
    false: 'false'
}

export const FalseLiteral = 'FalseLiteral';

export function isFalseLiteral(item: unknown): item is FalseLiteral {
    return reflection.isInstance(item, FalseLiteral);
}

export interface FieldClassMember extends AstNode {
    readonly $container: ClassDeclaration;
    readonly $type: 'FieldClassMember';
    initializer?: Expression
    name: ID
    private?: 'private'
    type: TypeExpression
}

export const FieldClassMember = 'FieldClassMember';

export function isFieldClassMember(item: unknown): item is FieldClassMember {
    return reflection.isInstance(item, FieldClassMember);
}

export interface FloatLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'FloatLiteral';
    value: string
}

export const FloatLiteral = 'FloatLiteral';

export function isFloatLiteral(item: unknown): item is FloatLiteral {
    return reflection.isInstance(item, FloatLiteral);
}

export interface FunctionDeclaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'FunctionDeclaration';
    async?: 'async'
    block: BlockStatement
    export?: 'export'
    name: ID
    parameters: Array<Parameter>
    returnType: TypeExpression
}

export const FunctionDeclaration = 'FunctionDeclaration';

export function isFunctionDeclaration(item: unknown): item is FunctionDeclaration {
    return reflection.isInstance(item, FunctionDeclaration);
}

export interface FunctionLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'FunctionLiteral';
    block: BlockStatement
    parameters: Array<Parameter>
    returnType: TypeExpression
    typeParameters: Array<TypeExpression>
}

export const FunctionLiteral = 'FunctionLiteral';

export function isFunctionLiteral(item: unknown): item is FunctionLiteral {
    return reflection.isInstance(item, FunctionLiteral);
}

export interface FunctionTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | ClassDeclaration | DeclareDeclaration | FieldClassMember | FunctionDeclaration | FunctionLiteral | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewExpression | TupleTypeExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator;
    readonly $type: 'FunctionTypeExpression';
    parameters: Array<TypeExpression>
    returnType: TypeExpression
}

export const FunctionTypeExpression = 'FunctionTypeExpression';

export function isFunctionTypeExpression(item: unknown): item is FunctionTypeExpression {
    return reflection.isInstance(item, FunctionTypeExpression);
}

export interface GetterClassMember extends AstNode {
    readonly $container: ClassDeclaration;
    readonly $type: 'GetterClassMember';
    block: BlockStatement
    name: ID
    private?: 'private'
    returnType: TypeExpression
}

export const GetterClassMember = 'GetterClassMember';

export function isGetterClassMember(item: unknown): item is GetterClassMember {
    return reflection.isInstance(item, GetterClassMember);
}

export interface GrabStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'GrabStatement';
    heldExpression: Expression
    statement: Statement
}

export const GrabStatement = 'GrabStatement';

export function isGrabStatement(item: unknown): item is GrabStatement {
    return reflection.isInstance(item, GrabStatement);
}

export interface GroupLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'GroupLiteral';
    expression: Expression
}

export const GroupLiteral = 'GroupLiteral';

export function isGroupLiteral(item: unknown): item is GroupLiteral {
    return reflection.isInstance(item, GroupLiteral);
}

export interface HeldTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | ClassDeclaration | DeclareDeclaration | FieldClassMember | FunctionDeclaration | FunctionLiteral | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewExpression | TupleTypeExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator;
    readonly $type: 'HeldTypeExpression';
    type: TypeExpression
}

export const HeldTypeExpression = 'HeldTypeExpression';

export function isHeldTypeExpression(item: unknown): item is HeldTypeExpression {
    return reflection.isInstance(item, HeldTypeExpression);
}

export interface HexLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'HexLiteral';
    value: string
}

export const HexLiteral = 'HexLiteral';

export function isHexLiteral(item: unknown): item is HexLiteral {
    return reflection.isInstance(item, HexLiteral);
}

export interface ID extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'ID';
    name: string
}

export const ID = 'ID';

export function isID(item: unknown): item is ID {
    return reflection.isInstance(item, ID);
}

export interface IfElseStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'IfElseStatement';
    condition: Expression
    falsy?: Statement
    truthy: Statement
}

export const IfElseStatement = 'IfElseStatement';

export function isIfElseStatement(item: unknown): item is IfElseStatement {
    return reflection.isInstance(item, IfElseStatement);
}

export interface ImportDeclaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'ImportDeclaration';
    declarators: Array<ImportDeclarator>
    path: string
}

export const ImportDeclaration = 'ImportDeclaration';

export function isImportDeclaration(item: unknown): item is ImportDeclaration {
    return reflection.isInstance(item, ImportDeclaration);
}

export interface ImportDeclarator extends AstNode {
    readonly $container: ImportDeclaration;
    readonly $type: 'ImportDeclarator';
    alias?: ID
    name: ID
}

export const ImportDeclarator = 'ImportDeclarator';

export function isImportDeclarator(item: unknown): item is ImportDeclarator {
    return reflection.isInstance(item, ImportDeclarator);
}

export interface IntegerLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'IntegerLiteral';
    value: string
}

export const IntegerLiteral = 'IntegerLiteral';

export function isIntegerLiteral(item: unknown): item is IntegerLiteral {
    return reflection.isInstance(item, IntegerLiteral);
}

export interface LeftUnaryExpression extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'AwaitExpression' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'FunctionLiteral' | 'GroupLiteral' | 'HexLiteral' | 'HoldExpression' | 'ID' | 'IntegerLiteral' | 'LeftUnaryExpression' | 'NewExpression' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: LeftUnaryExpression
    op: '!' | '+' | '-' | '~'
}

export const LeftUnaryExpression = 'LeftUnaryExpression';

export function isLeftUnaryExpression(item: unknown): item is LeftUnaryExpression {
    return reflection.isInstance(item, LeftUnaryExpression);
}

export interface MemberAccessPath extends AstNode {
    readonly $container: PathExpression;
    readonly $type: 'MemberAccessPath';
    member: ID
}

export const MemberAccessPath = 'MemberAccessPath';

export function isMemberAccessPath(item: unknown): item is MemberAccessPath {
    return reflection.isInstance(item, MemberAccessPath);
}

export interface MethodClassMember extends AstNode {
    readonly $container: ClassDeclaration;
    readonly $type: 'MethodClassMember';
    block: BlockStatement
    name: ID
    parameters: Array<Parameter>
    private?: 'private'
    returnType: TypeExpression
}

export const MethodClassMember = 'MethodClassMember';

export function isMethodClassMember(item: unknown): item is MethodClassMember {
    return reflection.isInstance(item, MethodClassMember);
}

export interface NamedTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | ClassDeclaration | DeclareDeclaration | FieldClassMember | FunctionDeclaration | FunctionLiteral | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewExpression | TupleTypeExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator;
    readonly $type: 'NamedTypeExpression';
    name: ID
    typeParameters: Array<TypeExpression>
}

export const NamedTypeExpression = 'NamedTypeExpression';

export function isNamedTypeExpression(item: unknown): item is NamedTypeExpression {
    return reflection.isInstance(item, NamedTypeExpression);
}

export interface NullLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'NullLiteral';
    null: 'null'
}

export const NullLiteral = 'NullLiteral';

export function isNullLiteral(item: unknown): item is NullLiteral {
    return reflection.isInstance(item, NullLiteral);
}

export interface OctalLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'OctalLiteral';
    value: string
}

export const OctalLiteral = 'OctalLiteral';

export function isOctalLiteral(item: unknown): item is OctalLiteral {
    return reflection.isInstance(item, OctalLiteral);
}

export interface Parameter extends AstNode {
    readonly $container: ConstructorClassMember | DeclareDeclaration | FunctionDeclaration | FunctionLiteral | MethodClassMember | SetterClassMember;
    readonly $type: 'Parameter';
    name: ID
    type: ID
}

export const Parameter = 'Parameter';

export function isParameter(item: unknown): item is Parameter {
    return reflection.isInstance(item, Parameter);
}

export interface Program extends AstNode {
    readonly $type: 'Program';
    declarations: Array<ClassDeclaration> | Array<DeclareDeclaration> | Array<FunctionDeclaration> | Array<TypeDeclaration>
    exports: Array<ExportDeclaration>
    imports: Array<ImportDeclaration>
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface ReturnStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'ReturnStatement';
    expression: Expression
}

export const ReturnStatement = 'ReturnStatement';

export function isReturnStatement(item: unknown): item is ReturnStatement {
    return reflection.isInstance(item, ReturnStatement);
}

export interface SetterClassMember extends AstNode {
    readonly $container: ClassDeclaration;
    readonly $type: 'SetterClassMember';
    block: BlockStatement
    name: ID
    parameter: Parameter
    private?: 'private'
}

export const SetterClassMember = 'SetterClassMember';

export function isSetterClassMember(item: unknown): item is SetterClassMember {
    return reflection.isInstance(item, SetterClassMember);
}

export interface StringLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'StringLiteral';
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface SuperLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'SuperLiteral';
    super: 'super'
}

export const SuperLiteral = 'SuperLiteral';

export function isSuperLiteral(item: unknown): item is SuperLiteral {
    return reflection.isInstance(item, SuperLiteral);
}

export interface ThisLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'ThisLiteral';
    this: 'this'
}

export const ThisLiteral = 'ThisLiteral';

export function isThisLiteral(item: unknown): item is ThisLiteral {
    return reflection.isInstance(item, ThisLiteral);
}

export interface TrueLiteral extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'TrueLiteral';
    true: 'true'
}

export const TrueLiteral = 'TrueLiteral';

export function isTrueLiteral(item: unknown): item is TrueLiteral {
    return reflection.isInstance(item, TrueLiteral);
}

export interface TupleExpression extends AstNode {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AssignmentExpression' | 'BinaryExpression' | 'TernaryExpression' | 'TupleExpression' | 'YieldExpression';
    expressions: Array<Expression>
}

export const TupleExpression = 'TupleExpression';

export function isTupleExpression(item: unknown): item is TupleExpression {
    return reflection.isInstance(item, TupleExpression);
}

export interface TupleTypeExpression extends AstNode {
    readonly $container: AsyncBlockLiteral | CallPath | ClassDeclaration | DeclareDeclaration | FieldClassMember | FunctionDeclaration | FunctionLiteral | FunctionTypeExpression | GetterClassMember | HeldTypeExpression | MethodClassMember | NamedTypeExpression | NewExpression | TupleTypeExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator;
    readonly $type: 'TupleTypeExpression';
    types: Array<TypeExpression>
}

export const TupleTypeExpression = 'TupleTypeExpression';

export function isTupleTypeExpression(item: unknown): item is TupleTypeExpression {
    return reflection.isInstance(item, TupleTypeExpression);
}

export interface TypeDeclaration extends AstNode {
    readonly $container: Program;
    readonly $type: 'TypeDeclaration';
    export?: 'export'
    name: ID
    type: TypeExpression
    typeParameters: Array<ID>
}

export const TypeDeclaration = 'TypeDeclaration';

export function isTypeDeclaration(item: unknown): item is TypeDeclaration {
    return reflection.isInstance(item, TypeDeclaration);
}

export interface TypeDeclarationStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'TypeDeclarationStatement';
    name: ID
    type: TypeExpression
    typeParameters: Array<ID>
}

export const TypeDeclarationStatement = 'TypeDeclarationStatement';

export function isTypeDeclarationStatement(item: unknown): item is TypeDeclarationStatement {
    return reflection.isInstance(item, TypeDeclarationStatement);
}

export interface VariableDeclarationStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'VariableDeclarationStatement';
    declarationType: 'const' | 'let'
    declarators: Array<VariableDeclarator>
}

export const VariableDeclarationStatement = 'VariableDeclarationStatement';

export function isVariableDeclarationStatement(item: unknown): item is VariableDeclarationStatement {
    return reflection.isInstance(item, VariableDeclarationStatement);
}

export interface VariableDeclarator extends AstNode {
    readonly $container: VariableDeclarationStatement;
    readonly $type: 'VariableDeclarator';
    expression: Expression
    name: ID
    type?: TypeExpression
}

export const VariableDeclarator = 'VariableDeclarator';

export function isVariableDeclarator(item: unknown): item is VariableDeclarator {
    return reflection.isInstance(item, VariableDeclarator);
}

export interface WhileStatement extends AstNode {
    readonly $container: AsyncBlockLiteral | BlockStatement | ConstructorClassMember | FunctionDeclaration | FunctionLiteral | GetterClassMember | GrabStatement | IfElseStatement | MethodClassMember | SetterClassMember | WhileStatement;
    readonly $type: 'WhileStatement';
    expression: Expression
    statement: Statement
}

export const WhileStatement = 'WhileStatement';

export function isWhileStatement(item: unknown): item is WhileStatement {
    return reflection.isInstance(item, WhileStatement);
}

export interface AwaitExpression extends LeftUnaryExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'AwaitExpression' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'FunctionLiteral' | 'GroupLiteral' | 'HexLiteral' | 'HoldExpression' | 'ID' | 'IntegerLiteral' | 'NewExpression' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: LeftUnaryExpression
}

export const AwaitExpression = 'AwaitExpression';

export function isAwaitExpression(item: unknown): item is AwaitExpression {
    return reflection.isInstance(item, AwaitExpression);
}

export interface YieldExpression extends TupleExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AssignmentExpression' | 'BinaryExpression' | 'TernaryExpression' | 'YieldExpression';
    expression: YieldExpression
}

export const YieldExpression = 'YieldExpression';

export function isYieldExpression(item: unknown): item is YieldExpression {
    return reflection.isInstance(item, YieldExpression);
}

export interface HoldExpression extends AwaitExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'FunctionLiteral' | 'GroupLiteral' | 'HexLiteral' | 'HoldExpression' | 'ID' | 'IntegerLiteral' | 'NewExpression' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: LeftUnaryExpression
}

export const HoldExpression = 'HoldExpression';

export function isHoldExpression(item: unknown): item is HoldExpression {
    return reflection.isInstance(item, HoldExpression);
}

export interface TernaryExpression extends YieldExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AssignmentExpression' | 'BinaryExpression' | 'TernaryExpression';
    condition: AssignmentExpression
    falsy: TernaryExpression
    truthy: TernaryExpression
}

export const TernaryExpression = 'TernaryExpression';

export function isTernaryExpression(item: unknown): item is TernaryExpression {
    return reflection.isInstance(item, TernaryExpression);
}

export interface NewExpression extends HoldExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'FunctionLiteral' | 'GroupLiteral' | 'HexLiteral' | 'ID' | 'IntegerLiteral' | 'NewExpression' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    expression: NewExpression
    parameters: Array<Expression>
    typeParameters: Array<TypeExpression>
}

export const NewExpression = 'NewExpression';

export function isNewExpression(item: unknown): item is NewExpression {
    return reflection.isInstance(item, NewExpression);
}

export interface PathExpression extends NewExpression {
    readonly $container: ArrayAccessPath | AwaitExpression | BinaryExpression | CallPath | ClassDeclaration | DeclareDeclaration | ExportDeclarator | ExpressionStatement | FieldClassMember | FunctionDeclaration | GetterClassMember | GrabStatement | GroupLiteral | HoldExpression | IfElseStatement | ImportDeclarator | LeftUnaryExpression | MemberAccessPath | MethodClassMember | NamedTypeExpression | NewExpression | Parameter | PathExpression | ReturnStatement | SetterClassMember | TernaryExpression | TupleExpression | TypeDeclaration | TypeDeclarationStatement | VariableDeclarator | WhileStatement | YieldExpression;
    readonly $type: 'AsyncBlockLiteral' | 'BinaryLiteral' | 'FalseLiteral' | 'FloatLiteral' | 'FunctionLiteral' | 'GroupLiteral' | 'HexLiteral' | 'ID' | 'IntegerLiteral' | 'NullLiteral' | 'OctalLiteral' | 'PathExpression' | 'PrimaryExpression' | 'StringLiteral' | 'SuperLiteral' | 'ThisLiteral' | 'TrueLiteral';
    path: Array<ArrayAccessPath> | Array<CallPath> | Array<MemberAccessPath>
    root: PrimaryExpression
}

export const PathExpression = 'PathExpression';

export function isPathExpression(item: unknown): item is PathExpression {
    return reflection.isInstance(item, PathExpression);
}

export interface WhackoAstType {
    ArrayAccessPath: ArrayAccessPath
    AssignmentExpression: AssignmentExpression
    AsyncBlockLiteral: AsyncBlockLiteral
    AwaitExpression: AwaitExpression
    BinaryExpression: BinaryExpression
    BinaryLiteral: BinaryLiteral
    BitShiftExpression: BitShiftExpression
    BitwiseAndExpression: BitwiseAndExpression
    BitwiseOrExpression: BitwiseOrExpression
    BitwiseXOrExpression: BitwiseXOrExpression
    BlockStatement: BlockStatement
    BreakStatement: BreakStatement
    CallPath: CallPath
    ClassDeclaration: ClassDeclaration
    ClassMember: ClassMember
    ComaprisonExpression: ComaprisonExpression
    ConstructorClassMember: ConstructorClassMember
    ContinueStatement: ContinueStatement
    DeclareDeclaration: DeclareDeclaration
    EqualityExpression: EqualityExpression
    ExponentiationExpression: ExponentiationExpression
    ExportDeclaration: ExportDeclaration
    ExportDeclarator: ExportDeclarator
    Expression: Expression
    ExpressionStatement: ExpressionStatement
    FalseLiteral: FalseLiteral
    FieldClassMember: FieldClassMember
    FloatLiteral: FloatLiteral
    FunctionDeclaration: FunctionDeclaration
    FunctionLiteral: FunctionLiteral
    FunctionTypeExpression: FunctionTypeExpression
    GetterClassMember: GetterClassMember
    GrabStatement: GrabStatement
    GroupLiteral: GroupLiteral
    HeldTypeExpression: HeldTypeExpression
    HexLiteral: HexLiteral
    HoldExpression: HoldExpression
    ID: ID
    IfElseStatement: IfElseStatement
    ImportDeclaration: ImportDeclaration
    ImportDeclarator: ImportDeclarator
    IntegerLiteral: IntegerLiteral
    LeftUnaryExpression: LeftUnaryExpression
    LogicalAndExpression: LogicalAndExpression
    LogicalOrExpression: LogicalOrExpression
    MemberAccessPath: MemberAccessPath
    MethodClassMember: MethodClassMember
    NamedTypeExpression: NamedTypeExpression
    NewExpression: NewExpression
    NullLiteral: NullLiteral
    OctalLiteral: OctalLiteral
    Parameter: Parameter
    PathExpression: PathExpression
    PrimaryExpression: PrimaryExpression
    ProductExpression: ProductExpression
    Program: Program
    ReturnStatement: ReturnStatement
    SetterClassMember: SetterClassMember
    Statement: Statement
    StringLiteral: StringLiteral
    SumExpression: SumExpression
    SuperLiteral: SuperLiteral
    TernaryExpression: TernaryExpression
    ThisLiteral: ThisLiteral
    TrueLiteral: TrueLiteral
    TupleExpression: TupleExpression
    TupleTypeExpression: TupleTypeExpression
    TypeDeclaration: TypeDeclaration
    TypeDeclarationStatement: TypeDeclarationStatement
    TypeExpression: TypeExpression
    VariableDeclarationStatement: VariableDeclarationStatement
    VariableDeclarator: VariableDeclarator
    WhileStatement: WhileStatement
    YieldExpression: YieldExpression
}

export class WhackoAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['ArrayAccessPath', 'AssignmentExpression', 'AsyncBlockLiteral', 'AwaitExpression', 'BinaryExpression', 'BinaryLiteral', 'BitShiftExpression', 'BitwiseAndExpression', 'BitwiseOrExpression', 'BitwiseXOrExpression', 'BlockStatement', 'BreakStatement', 'CallPath', 'ClassDeclaration', 'ClassMember', 'ComaprisonExpression', 'ConstructorClassMember', 'ContinueStatement', 'DeclareDeclaration', 'EqualityExpression', 'ExponentiationExpression', 'ExportDeclaration', 'ExportDeclarator', 'Expression', 'ExpressionStatement', 'FalseLiteral', 'FieldClassMember', 'FloatLiteral', 'FunctionDeclaration', 'FunctionLiteral', 'FunctionTypeExpression', 'GetterClassMember', 'GrabStatement', 'GroupLiteral', 'HeldTypeExpression', 'HexLiteral', 'HoldExpression', 'ID', 'IfElseStatement', 'ImportDeclaration', 'ImportDeclarator', 'IntegerLiteral', 'LeftUnaryExpression', 'LogicalAndExpression', 'LogicalOrExpression', 'MemberAccessPath', 'MethodClassMember', 'NamedTypeExpression', 'NewExpression', 'NullLiteral', 'OctalLiteral', 'Parameter', 'PathExpression', 'PrimaryExpression', 'ProductExpression', 'Program', 'ReturnStatement', 'SetterClassMember', 'Statement', 'StringLiteral', 'SumExpression', 'SuperLiteral', 'TernaryExpression', 'ThisLiteral', 'TrueLiteral', 'TupleExpression', 'TupleTypeExpression', 'TypeDeclaration', 'TypeDeclarationStatement', 'TypeExpression', 'VariableDeclarationStatement', 'VariableDeclarator', 'WhileStatement', 'YieldExpression'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AsyncBlockLiteral:
            case BinaryLiteral:
            case FalseLiteral:
            case FloatLiteral:
            case FunctionLiteral:
            case GroupLiteral:
            case HexLiteral:
            case ID:
            case IntegerLiteral:
            case NullLiteral:
            case OctalLiteral:
            case StringLiteral:
            case SuperLiteral:
            case ThisLiteral:
            case TrueLiteral: {
                return this.isSubtype(PrimaryExpression, supertype);
            }
            case BinaryExpression: {
                return this.isSubtype(AssignmentExpression, supertype) || this.isSubtype(LogicalOrExpression, supertype) || this.isSubtype(LogicalAndExpression, supertype) || this.isSubtype(BitwiseOrExpression, supertype) || this.isSubtype(BitwiseXOrExpression, supertype) || this.isSubtype(BitwiseAndExpression, supertype) || this.isSubtype(EqualityExpression, supertype) || this.isSubtype(ComaprisonExpression, supertype) || this.isSubtype(BitShiftExpression, supertype) || this.isSubtype(SumExpression, supertype) || this.isSubtype(ProductExpression, supertype) || this.isSubtype(ExponentiationExpression, supertype);
            }
            case BlockStatement:
            case BreakStatement:
            case ContinueStatement:
            case ExpressionStatement:
            case GrabStatement:
            case IfElseStatement:
            case ReturnStatement:
            case TypeDeclarationStatement:
            case VariableDeclarationStatement:
            case WhileStatement: {
                return this.isSubtype(Statement, supertype);
            }
            case ConstructorClassMember:
            case FieldClassMember:
            case GetterClassMember:
            case MethodClassMember:
            case SetterClassMember: {
                return this.isSubtype(ClassMember, supertype);
            }
            case FunctionTypeExpression:
            case HeldTypeExpression:
            case NamedTypeExpression:
            case TupleTypeExpression: {
                return this.isSubtype(TypeExpression, supertype);
            }
            case LeftUnaryExpression: {
                return this.isSubtype(ExponentiationExpression, supertype);
            }
            case TupleExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case AwaitExpression: {
                return this.isSubtype(LeftUnaryExpression, supertype);
            }
            case YieldExpression: {
                return this.isSubtype(TupleExpression, supertype);
            }
            case HoldExpression: {
                return this.isSubtype(AwaitExpression, supertype);
            }
            case TernaryExpression: {
                return this.isSubtype(YieldExpression, supertype);
            }
            case NewExpression: {
                return this.isSubtype(HoldExpression, supertype);
            }
            case PathExpression: {
                return this.isSubtype(AssignmentExpression, supertype) || this.isSubtype(NewExpression, supertype);
            }
            case AssignmentExpression: {
                return this.isSubtype(TernaryExpression, supertype);
            }
            case BitShiftExpression: {
                return this.isSubtype(ComaprisonExpression, supertype);
            }
            case BitwiseAndExpression: {
                return this.isSubtype(BitwiseXOrExpression, supertype);
            }
            case BitwiseOrExpression: {
                return this.isSubtype(LogicalAndExpression, supertype);
            }
            case BitwiseXOrExpression: {
                return this.isSubtype(BitwiseOrExpression, supertype);
            }
            case ComaprisonExpression: {
                return this.isSubtype(EqualityExpression, supertype);
            }
            case EqualityExpression: {
                return this.isSubtype(BitwiseAndExpression, supertype);
            }
            case ExponentiationExpression: {
                return this.isSubtype(ProductExpression, supertype);
            }
            case LogicalAndExpression: {
                return this.isSubtype(LogicalOrExpression, supertype);
            }
            case LogicalOrExpression: {
                return this.isSubtype(AssignmentExpression, supertype);
            }
            case PrimaryExpression: {
                return this.isSubtype(PathExpression, supertype);
            }
            case ProductExpression: {
                return this.isSubtype(SumExpression, supertype);
            }
            case SumExpression: {
                return this.isSubtype(BitShiftExpression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'BlockStatement': {
                return {
                    name: 'BlockStatement',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'CallPath': {
                return {
                    name: 'CallPath',
                    mandatory: [
                        { name: 'parameters', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'ClassDeclaration': {
                return {
                    name: 'ClassDeclaration',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            case 'ConstructorClassMember': {
                return {
                    name: 'ConstructorClassMember',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'DeclareDeclaration': {
                return {
                    name: 'DeclareDeclaration',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'ExportDeclaration': {
                return {
                    name: 'ExportDeclaration',
                    mandatory: [
                        { name: 'declarators', type: 'array' }
                    ]
                };
            }
            case 'FunctionDeclaration': {
                return {
                    name: 'FunctionDeclaration',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'FunctionLiteral': {
                return {
                    name: 'FunctionLiteral',
                    mandatory: [
                        { name: 'parameters', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'FunctionTypeExpression': {
                return {
                    name: 'FunctionTypeExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'ImportDeclaration': {
                return {
                    name: 'ImportDeclaration',
                    mandatory: [
                        { name: 'declarators', type: 'array' }
                    ]
                };
            }
            case 'MethodClassMember': {
                return {
                    name: 'MethodClassMember',
                    mandatory: [
                        { name: 'parameters', type: 'array' }
                    ]
                };
            }
            case 'NamedTypeExpression': {
                return {
                    name: 'NamedTypeExpression',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'Program': {
                return {
                    name: 'Program',
                    mandatory: [
                        { name: 'declarations', type: 'array' },
                        { name: 'exports', type: 'array' },
                        { name: 'imports', type: 'array' }
                    ]
                };
            }
            case 'TupleExpression': {
                return {
                    name: 'TupleExpression',
                    mandatory: [
                        { name: 'expressions', type: 'array' }
                    ]
                };
            }
            case 'TupleTypeExpression': {
                return {
                    name: 'TupleTypeExpression',
                    mandatory: [
                        { name: 'types', type: 'array' }
                    ]
                };
            }
            case 'TypeDeclaration': {
                return {
                    name: 'TypeDeclaration',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'TypeDeclarationStatement': {
                return {
                    name: 'TypeDeclarationStatement',
                    mandatory: [
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'VariableDeclarationStatement': {
                return {
                    name: 'VariableDeclarationStatement',
                    mandatory: [
                        { name: 'declarators', type: 'array' }
                    ]
                };
            }
            case 'YieldExpression': {
                return {
                    name: 'YieldExpression',
                    mandatory: [
                        { name: 'expressions', type: 'array' }
                    ]
                };
            }
            case 'TernaryExpression': {
                return {
                    name: 'TernaryExpression',
                    mandatory: [
                        { name: 'expressions', type: 'array' }
                    ]
                };
            }
            case 'NewExpression': {
                return {
                    name: 'NewExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            case 'PathExpression': {
                return {
                    name: 'PathExpression',
                    mandatory: [
                        { name: 'parameters', type: 'array' },
                        { name: 'path', type: 'array' },
                        { name: 'typeParameters', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new WhackoAstReflection();
